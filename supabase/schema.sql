
-- Enable the http extension if not already enabled
create extension if not exists http with schema extensions;

-- Create custom types for roles and genders
create type public.user_role as enum ('user', 'admin', 'gurudev');
create type public.user_gender as enum ('male', 'female');

-- Create a table for public profiles
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  name text,
  username text,
  avatar_url text,
  bio text,
  role public.user_role default 'user'::public.user_role,
  is_admin boolean default false,
  gender public.user_gender,
  primary key (id),
  unique (username)
);
alter table public.profiles enable row level security;

-- Create policies for profiles table
create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);
create policy "Admins can update any profile" on public.profiles for update using ( (select is_admin from public.profiles where id = auth.uid()));

-- Create a table for chats
create type public.chat_type as enum ('dm', 'group', 'channel');
create table public.chats (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  type public.chat_type not null default 'group'::public.chat_type,
  name text,
  avatar_url text,
  description text,
  created_by uuid references auth.users(id),
  is_public boolean default false,
  history_visible boolean default true,
  invite_code text unique
);
alter table public.chats enable row level security;

-- Create policies for chats table
create policy "Users can view chats they are a member of" on public.chats for select using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid()));
create policy "Users can create chats." on public.chats for insert with check (true);
create policy "Admins of a group can update it." on public.chats for update using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid() and is_admin = true));
create policy "Admins of a group can delete it." on public.chats for delete using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid() and is_admin = true));

-- Create a table for chat participants
create table public.participants (
  chat_id bigint not null references public.chats on delete cascade,
  user_id uuid not null references public.profiles on delete cascade,
  is_admin boolean default false,
  primary key (chat_id, user_id)
);
alter table public.participants enable row level security;

-- Create policies for participants table
create policy "Users can view participants of chats they are a member of." on public.participants for select using (exists (select 1 from public.participants as p where p.chat_id = participants.chat_id and p.user_id = auth.uid()));
create policy "Admins can add users to a group." on public.participants for insert with check (exists (select 1 from public.participants where chat_id = participants.chat_id and user_id = auth.uid() and is_admin = true));
create policy "Admins can remove users from a group." on public.participants for delete using (exists (select 1 from public.participants where chat_id = participants.chat_id and user_id = auth.uid() and is_admin = true));
create policy "Admins can update participant roles." on public.participants for update using (exists (select 1 from public.participants where chat_id = participants.chat_id and user_id = auth.uid() and is_admin = true));

-- Create a table for messages
create table public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  chat_id bigint not null references public.chats on delete cascade,
  user_id uuid not null references public.profiles on delete cascade,
  content text,
  attachment_url text,
  attachment_metadata jsonb,
  is_edited boolean default false,
  reactions jsonb,
  read_by uuid[],
  deleted_for uuid[],
  is_starred boolean default false,
  is_pinned boolean default false,
  reply_to_message_id bigint references public.messages on delete set null
);
alter table public.messages enable row level security;

-- Create policies for messages table
create policy "Users can view messages in chats they are a member of." on public.messages for select using (exists (select 1 from public.participants where chat_id = messages.chat_id and user_id = auth.uid()));
create policy "Users can send messages in chats they are a member of." on public.messages for insert with check (exists (select 1 from public.participants where chat_id = messages.chat_id and user_id = auth.uid()));
create policy "Users can edit their own messages." on public.messages for update using (user_id = auth.uid());
create policy "Group admins can pin any message." on public.messages for update using (exists (select 1 from public.participants where chat_id = messages.chat_id and user_id = auth.uid() and is_admin = true));

-- Create a table for blocked users
create table public.blocked_users (
  blocker_id uuid not null references public.profiles on delete cascade,
  blocked_id uuid not null references public.profiles on delete cascade,
  created_at timestamp with time zone default now(),
  primary key (blocker_id, blocked_id)
);
alter table public.blocked_users enable row level security;
create policy "Users can manage their own block list." on public.blocked_users using (auth.uid() = blocker_id);

-- Create a table for DM requests
create type public.dm_request_status as enum ('pending', 'approved', 'rejected');
create table public.dm_requests (
  id bigint generated by default as identity primary key,
  from_user_id uuid not null references public.profiles on delete cascade,
  to_user_id uuid not null references public.profiles on delete cascade,
  status public.dm_request_status default 'pending'::public.dm_request_status,
  reason text,
  created_at timestamp with time zone default now()
);
alter table public.dm_requests enable row level security;
create policy "Users can view their own DM requests." on public.dm_requests for select using (auth.uid() = from_user_id or auth.uid() = to_user_id);
create policy "Users can create DM requests." on public.dm_requests for insert with check (auth.uid() = from_user_id);
create policy "Admins can update any DM request." on public.dm_requests for update using ((select is_admin from public.profiles where id = auth.uid()));

-- Create a table for reports
create type public.report_status as enum ('pending', 'resolved', 'dismissed');
create table public.reports (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now(),
    reported_by uuid not null references public.profiles on delete cascade,
    reported_user_id uuid not null references public.profiles on delete cascade,
    message_id bigint references public.messages on delete set null,
    reason text not null,
    status public.report_status default 'pending'::public.report_status
);
alter table public.reports enable row level security;
create policy "Users can create reports" on public.reports for insert with check (auth.uid() = reported_by);
create policy "Admins can view and manage all reports" on public.reports for all using ((select is_admin from public.profiles where id = auth.uid()));

-- Create a table for events
create type public.event_status as enum ('active', 'cancelled');
create table public.events (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  creator_id uuid not null references public.profiles on delete cascade,
  title text not null,
  description text,
  thumbnail text,
  date_time timestamp with time zone not null,
  meet_link text,
  status public.event_status default 'active'::public.event_status,
  is_deleted boolean default false
);
alter table public.events enable row level security;
create policy "Events are public" on public.events for select using (true);
create policy "Admins can manage all events" on public.events for all using ((select is_admin from public.profiles where id = auth.uid()));
create policy "Users can create events if they are an admin" on public.events for insert with check ((select is_admin from public.profiles where id = auth.uid()));

-- Create a table for event RSVPs
create type public.rsvp_status as enum ('going', 'interested', 'not_going');
create table public.event_rsvps (
  event_id bigint not null references public.events on delete cascade,
  user_id uuid not null references public.profiles on delete cascade,
  status public.rsvp_status not null,
  created_at timestamp with time zone default now(),
  primary key (event_id, user_id)
);
alter table public.event_rsvps enable row level security;
create policy "Users can view all RSVPs" on public.event_rsvps for select using (true);
create policy "Users can manage their own RSVP" on public.event_rsvps for all using (auth.uid() = user_id);

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table public.messages, public.chats, public.participants, public.dm_requests, public.reports;

-- Set up Storage!
insert into storage.buckets (id, name, public)
values ('attachments', 'attachments', true);
create policy "Anyone can upload an attachment." on storage.objects for insert with check (true);
create policy "Anyone can view an attachment." on storage.objects for select using (true);

-- Set up a trigger to automatically create a profile for new users
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, name, username, avatar_url, gender)
  values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'username',
    new.raw_user_meta_data->>'avatar_url',
    (new.raw_user_meta_data->>'gender')::public.user_gender
  );
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Function to toggle a reaction on a message
create or replace function public.toggle_reaction(p_message_id bigint, p_user_id uuid, p_emoji text)
returns void
language plpgsql
as $$
declare
    v_reactions jsonb;
    v_user_reactions text[];
begin
    -- Get current reactions for the message
    select reactions into v_reactions from public.messages where id = p_message_id;

    -- Initialize reactions if null
    if v_reactions is null then
        v_reactions := '{}'::jsonb;
    end if;

    -- Get users who reacted with this emoji
    v_user_reactions := v_reactions->>p_emoji;

    if v_user_reactions is null then
        -- User has not reacted with this emoji, so add them
        v_user_reactions := array[p_user_id::text];
    else
        -- User has reacted, check if we should add or remove
        if p_user_id::text = any(v_user_reactions) then
            -- User is in the list, so remove them
            v_user_reactions := array_remove(v_user_reactions, p_user_id::text);
        else
            -- User is not in the list, so add them
            v_user_reactions := array_append(v_user_reactions, p_user_id::text);
        end if;
    end if;

    -- Update the reactions jsonb
    if array_length(v_user_reactions, 1) > 0 then
        v_reactions := jsonb_set(v_reactions, array[p_emoji], to_jsonb(v_user_reactions));
    else
        -- If no users are left for this emoji, remove the key
        v_reactions := v_reactions - p_emoji;
    end if;

    -- Update the message with the new reactions
    update public.messages
    set reactions = v_reactions
    where id = p_message_id;
end;
$$;


-- Function to mark messages as read for a user in a chat
create or replace function public.mark_messages_as_read(p_chat_id bigint, p_user_id uuid)
returns void
language plpgsql
as $$
begin
    update public.messages
    set read_by = (
        case
            when read_by is null then array[p_user_id]
            when not (read_by @> array[p_user_id]) then array_append(read_by, p_user_id)
            else read_by
        end
    )
    where chat_id = p_chat_id and not (read_by @> array[p_user_id]);
end;
$$;


-- Function to efficiently get the last message for a list of chats
create or replace function public.get_last_messages_for_chats(p_chat_ids bigint[])
returns table (
    chat_id bigint,
    content text,
    created_at timestamp with time zone,
    attachment_metadata jsonb
)
language sql
as $$
    select
        m.chat_id,
        m.content,
        m.created_at,
        m.attachment_metadata
    from
        public.messages m
    inner join (
        select
            chat_id,
            max(created_at) as max_created_at
        from
            public.messages
        where
            chat_id = any(p_chat_ids)
        group by
            chat_id
    ) lm on m.chat_id = lm.chat_id and m.created_at = lm.max_created_at
    where
        m.chat_id = any(p_chat_ids);
$$;

-- Create table for video/audio call sessions
create type public.call_status as enum ('ringing', 'active', 'ended', 'missed', 'rejected');
create type public.call_type as enum ('audio', 'video');

create table public.call_sessions (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  chat_id bigint not null references public.chats on delete cascade,
  initiated_by uuid not null references public.profiles on delete cascade,
  call_type public.call_type not null default 'audio'::public.call_type,
  status public.call_status not null default 'ringing'::public.call_status,
  started_at timestamp with time zone,
  ended_at timestamp with time zone
);
alter table public.call_sessions enable row level security;

-- Policies for call sessions
create policy "Users can view call sessions for their chats" on public.call_sessions for select using (exists (select 1 from public.participants where chat_id = call_sessions.chat_id and user_id = auth.uid()));
create policy "Users can create call sessions in their chats" on public.call_sessions for insert with check (exists (select 1 from public.participants where chat_id = call_sessions.chat_id and user_id = auth.uid()));
create policy "Initiators can update their call sessions" on public.call_sessions for update using (initiated_by = auth.uid());

-- Create table for call participants
create table public.call_participants (
  call_id bigint not null references public.call_sessions on delete cascade,
  user_id uuid not null references public.profiles on delete cascade,
  joined_at timestamp with time zone default now(),
  left_at timestamp with time zone,
  is_muted boolean default false,
  is_video_off boolean default false,
  is_screen_sharing boolean default false,
  primary key (call_id, user_id)
);
alter table public.call_participants enable row level security;

-- Policies for call participants
create policy "Users can view call participants" on public.call_participants for select using (exists (select 1 from public.call_sessions cs where cs.id = call_participants.call_id and exists (select 1 from public.participants p where p.chat_id = cs.chat_id and p.user_id = auth.uid())));
create policy "Users can join calls" on public.call_participants for insert with check (user_id = auth.uid());
create policy "Users can update their own participation" on public.call_participants for update using (user_id = auth.uid());

-- Add realtime for call tables
alter publication supabase_realtime add table public.call_sessions, public.call_participants;
