-- ============================================================================
--                    SCHEMA.SQL - DATABASE SCHEMA DEFINITIONS
--                    Complete Schema for Production Deployment
-- ============================================================================
-- Description: This file contains all table definitions, indexes, constraints,
--              RLS policies, and enum types for the application.
-- 
-- Version: 2.0 (Production Ready - QA Approved)
-- Usage: Execute this file first, followed by functions.sql
-- ============================================================================


-- ============================================================================
-- SECTION 1: ENUM TYPES
-- ============================================================================

-- ----------------------------------------------------------------------------
-- ENUM: user_role
-- Purpose: Defines available user roles in the system
-- ----------------------------------------------------------------------------
CREATE TYPE public.user_role AS ENUM ('user', 'admin', 'gurudev');

-- ----------------------------------------------------------------------------
-- ENUM: dm_request_status
-- Purpose: Defines the status of direct message requests
-- ----------------------------------------------------------------------------
CREATE TYPE public.dm_request_status AS ENUM ('pending', 'approved', 'rejected');

-- ----------------------------------------------------------------------------
-- ENUM: rsvp_status
-- Purpose: Defines RSVP response types for events
-- ----------------------------------------------------------------------------
CREATE TYPE public.rsvp_status AS ENUM ('going', 'interested', 'not_going');


-- ============================================================================
-- SECTION 2: TABLE DEFINITIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- TABLE: profiles
-- Purpose: Stores user profile information from authentication system
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID NOT NULL PRIMARY KEY,
    name TEXT,
    username TEXT UNIQUE,
    avatar_url TEXT,
    gender TEXT,
    bio TEXT,
    is_admin BOOLEAN DEFAULT FALSE,
    role public.user_role NOT NULL DEFAULT 'user',
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
);

COMMENT ON COLUMN public.profiles.role IS 'Specifies the role of the user, e.g., user, admin, or gurudev.';


-- ----------------------------------------------------------------------------
-- TABLE: chats
-- Purpose: Stores chat conversations (both DM and group chats)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.chats (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    type TEXT NOT NULL, -- 'dm' or 'group'
    name TEXT,
    avatar_url TEXT,
    description TEXT,
    created_by UUID REFERENCES public.profiles(id) DEFAULT auth.uid(),
    is_public BOOLEAN DEFAULT TRUE,
    history_visible BOOLEAN DEFAULT TRUE,
    invite_code UUID DEFAULT gen_random_uuid()
);


-- ----------------------------------------------------------------------------
-- TABLE: participants
-- Purpose: Maps users to their chat memberships with admin status
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.participants (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    chat_id BIGINT REFERENCES public.chats(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    is_admin BOOLEAN DEFAULT FALSE,
    UNIQUE(chat_id, user_id)
);


-- ----------------------------------------------------------------------------
-- TABLE: messages
-- Purpose: Stores chat messages with attachments, reactions, and metadata
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.messages (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    chat_id BIGINT REFERENCES public.chats(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    content TEXT,
    is_edited BOOLEAN DEFAULT FALSE,
    attachment_url TEXT,
    attachment_metadata JSONB,
    reactions JSONB,
    read_by UUID[] DEFAULT ARRAY[]::UUID[],
    deleted_for UUID[],
    is_pinned BOOLEAN DEFAULT FALSE,
    reply_to_message_id BIGINT NULL,
    CONSTRAINT messages_reply_to_message_id_fkey FOREIGN KEY (reply_to_message_id) 
        REFERENCES public.messages(id) ON DELETE SET NULL
);


-- ----------------------------------------------------------------------------
-- TABLE: dm_requests
-- Purpose: Stores requests for users to initiate direct messages
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.dm_requests (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    from_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    to_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status public.dm_request_status NOT NULL DEFAULT 'pending',
    reason TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT unique_dm_request UNIQUE (from_user_id, to_user_id)
);

COMMENT ON TABLE public.dm_requests IS 'Stores requests for users to DM each other, typically across genders.';
COMMENT ON COLUMN public.dm_requests.from_user_id IS 'The user initiating the request.';
COMMENT ON COLUMN public.dm_requests.to_user_id IS 'The user receiving the request.';
COMMENT ON COLUMN public.dm_requests.status IS 'The current status of the request: pending, approved, or rejected.';


-- ----------------------------------------------------------------------------
-- TABLE: reports
-- Purpose: Stores user reports for moderation
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.reports (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    reported_by UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    reported_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    message_id BIGINT NULL REFERENCES public.messages(id) ON DELETE SET NULL,
    reason TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending' -- 'pending', 'resolved', 'dismissed'
);

COMMENT ON COLUMN public.reports.status IS 'Can be pending, resolved, or dismissed';


-- ----------------------------------------------------------------------------
-- TABLE: blocked_users
-- Purpose: Tracks blocked user relationships
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.blocked_users (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    blocker_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    blocked_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    CONSTRAINT blocked_users_unique UNIQUE (blocker_id, blocked_id)
);


-- ----------------------------------------------------------------------------
-- TABLE: events
-- Purpose: Stores community events and meetings
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.events (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    creator_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    description TEXT,
    thumbnail TEXT,
    date_time TIMESTAMPTZ NOT NULL,
    meet_link TEXT,
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE
);


-- ----------------------------------------------------------------------------
-- TABLE: event_rsvps
-- Purpose: Tracks user RSVPs for events
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.event_rsvps (
    event_id BIGINT NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status public.rsvp_status NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (event_id, user_id)
);


-- ----------------------------------------------------------------------------
-- TABLE: statuses
-- Purpose: Stores user statuses/stories (expire after 24 hours)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.statuses (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    media_url TEXT NOT NULL,
    media_type TEXT NOT NULL DEFAULT 'image',
    caption TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL DEFAULT (NOW() + '1 day'::interval)
);


-- ----------------------------------------------------------------------------
-- TABLE: status_views
-- Purpose: Tracks who has viewed which status
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.status_views (
    status_id BIGINT NOT NULL REFERENCES public.statuses(id) ON DELETE CASCADE,
    viewer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    viewed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (status_id, viewer_id)
);


-- ============================================================================
-- SECTION 3: ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_rsvps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.statuses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.status_views ENABLE ROW LEVEL SECURITY;
-- Note: dm_requests RLS is intentionally disabled for operational flexibility


-- ----------------------------------------------------------------------------
-- POLICIES: profiles
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." 
    ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." 
    ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." 
    ON public.profiles FOR UPDATE USING (auth.uid() = id);


-- ----------------------------------------------------------------------------
-- POLICIES: chats
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Authenticated users can create chats." ON public.chats;
CREATE POLICY "Authenticated users can create chats." 
    ON public.chats FOR INSERT TO authenticated WITH CHECK (true);

DROP POLICY IF EXISTS "Users can view chats they participate in." ON public.chats;
CREATE POLICY "Users can view chats they participate in." 
    ON public.chats FOR SELECT 
    USING (
        EXISTS (
            SELECT 1 FROM public.participants 
            WHERE chat_id = chats.id AND user_id = auth.uid()
        )
    );


-- ----------------------------------------------------------------------------
-- POLICIES: participants
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Chat creators can add participants." ON public.participants;
CREATE POLICY "Chat creators can add participants." 
    ON public.participants FOR INSERT 
    WITH CHECK (
        (SELECT created_by FROM public.chats WHERE id = chat_id) = auth.uid()
    );

DROP POLICY IF EXISTS "Users can view participants of chats they are in." ON public.participants;
CREATE POLICY "Users can view participants of chats they are in." 
    ON public.participants FOR SELECT 
    USING (
        EXISTS (
            SELECT 1 FROM public.participants 
            WHERE chat_id = participants.chat_id AND user_id = auth.uid()
        )
    );


-- ----------------------------------------------------------------------------
-- POLICIES: messages
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Users can send messages in chats they participate in." ON public.messages;
CREATE POLICY "Users can send messages in chats they participate in."
    ON public.messages FOR INSERT TO authenticated
    WITH CHECK (
        (user_id = auth.uid()) AND 
        (chat_id IN (
            SELECT p.chat_id FROM public.participants p WHERE p.user_id = auth.uid()
        ))
    );

DROP POLICY IF EXISTS "Users can view messages in chats they participate in." ON public.messages;
CREATE POLICY "Users can view messages in chats they participate in."
    ON public.messages FOR SELECT TO authenticated
    USING (
        chat_id IN (
            SELECT p.chat_id FROM public.participants p WHERE p.user_id = auth.uid()
        )
    );

DROP POLICY IF EXISTS "Users can delete their own messages." ON public.messages;
CREATE POLICY "Users can delete their own messages."
    ON public.messages FOR DELETE TO authenticated
    USING (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can update their own messages." ON public.messages;
CREATE POLICY "Users can update their own messages."
    ON public.messages FOR UPDATE TO authenticated
    USING (true)
    WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Enable UPDATE for group admins on messages" ON public.messages;
CREATE POLICY "Enable UPDATE for group admins on messages"
    ON public.messages FOR UPDATE
    USING (
        (SELECT is_admin FROM public.participants 
         WHERE participants.chat_id = messages.chat_id 
         AND participants.user_id = auth.uid()) = true
    )
    WITH CHECK (
        (SELECT is_admin FROM public.participants 
         WHERE participants.chat_id = messages.chat_id 
         AND participants.user_id = auth.uid()) = true
    );


-- ----------------------------------------------------------------------------
-- POLICIES: reports
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage all reports" ON public.reports;
CREATE POLICY "Admins can manage all reports"
    ON public.reports FOR ALL
    USING (
        (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true
    );

DROP POLICY IF EXISTS "Users can insert their own reports" ON public.reports;
CREATE POLICY "Users can insert their own reports"
    ON public.reports FOR INSERT
    WITH CHECK (auth.uid() = reported_by);


-- ----------------------------------------------------------------------------
-- POLICIES: blocked_users
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Users can manage their own block list" ON public.blocked_users;
CREATE POLICY "Users can manage their own block list"
    ON public.blocked_users FOR ALL
    USING (auth.uid() = blocker_id);


-- ----------------------------------------------------------------------------
-- POLICIES: events
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Public can read all events." ON public.events;
CREATE POLICY "Public can read all events." 
    ON public.events FOR SELECT USING (true);

DROP POLICY IF EXISTS "Admins can create events." ON public.events;
CREATE POLICY "Admins can create events." 
    ON public.events FOR INSERT 
    WITH CHECK (
        (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true
    );

DROP POLICY IF EXISTS "Admins or event creator can update events." ON public.events;
CREATE POLICY "Admins or event creator can update events." 
    ON public.events FOR UPDATE 
    USING (
        (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true OR
        creator_id = auth.uid()
    );

DROP POLICY IF EXISTS "Admins or event creator can delete events." ON public.events;
CREATE POLICY "Admins or event creator can delete events." 
    ON public.events FOR DELETE 
    USING (
        (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true OR
        creator_id = auth.uid()
    );


-- ----------------------------------------------------------------------------
-- POLICIES: event_rsvps
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Public can read all RSVPs." ON public.event_rsvps;
CREATE POLICY "Public can read all RSVPs." 
    ON public.event_rsvps FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own RSVP." ON public.event_rsvps;
CREATE POLICY "Users can insert their own RSVP." 
    ON public.event_rsvps FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update their own RSVP." ON public.event_rsvps;
CREATE POLICY "Users can update their own RSVP." 
    ON public.event_rsvps FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own RSVP." ON public.event_rsvps;
CREATE POLICY "Users can delete their own RSVP." 
    ON public.event_rsvps FOR DELETE USING (auth.uid() = user_id);


-- ----------------------------------------------------------------------------
-- POLICIES: statuses
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Users can view their own statuses" ON public.statuses;
CREATE POLICY "Users can view their own statuses"
    ON public.statuses FOR SELECT
    USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can create their own statuses" ON public.statuses;
CREATE POLICY "Users can create their own statuses"
    ON public.statuses FOR INSERT
    WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own statuses" ON public.statuses;
CREATE POLICY "Users can delete their own statuses"
    ON public.statuses FOR DELETE
    USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view all non-expired statuses" ON public.statuses;
CREATE POLICY "Users can view all non-expired statuses"
    ON public.statuses FOR SELECT
    USING (expires_at > NOW());


-- ----------------------------------------------------------------------------
-- POLICIES: status_views
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "Users can view their own views" ON public.status_views;
CREATE POLICY "Users can view their own views"
    ON public.status_views FOR SELECT
    USING (auth.uid() = viewer_id);

DROP POLICY IF EXISTS "Users can mark a status as viewed" ON public.status_views;
CREATE POLICY "Users can mark a status as viewed"
    ON public.status_views FOR INSERT
    WITH CHECK (auth.uid() = viewer_id);


-- ----------------------------------------------------------------------------
-- POLICIES: storage.objects (attachments bucket)
-- Note: Storage policies must be created through Supabase Dashboard or 
--       with proper storage admin permissions. These are provided as reference.
-- ----------------------------------------------------------------------------

-- STORAGE POLICY REFERENCE (Create these in Supabase Dashboard -> Storage -> Policies):
-- 
-- Policy Name: "Authenticated users can upload attachments"
-- Allowed operation: INSERT
-- Policy definition:
--   WITH CHECK (bucket_id = 'attachments' AND auth.role() = 'authenticated')
--
-- Policy Name: "Anyone can view attachments"
-- Allowed operation: SELECT
-- Policy definition:
--   USING (bucket_id = 'attachments')


-- ----------------------------------------------------------------------------
-- POLICIES: storage.objects (story bucket)
-- Note: Storage policies must be created through Supabase Dashboard or 
--       with proper storage admin permissions. These are provided as reference.
-- ----------------------------------------------------------------------------

-- STORAGE POLICY REFERENCE (Create these in Supabase Dashboard -> Storage -> Policies):
--
-- Policy Name: "Allow authenticated read access to stories"
-- Allowed operation: SELECT
-- Policy definition:
--   USING (bucket_id = 'story' AND auth.role() = 'authenticated')
--
-- Policy Name: "Allow individual user uploads to stories"
-- Allowed operation: INSERT
-- Policy definition:
--   WITH CHECK (bucket_id = 'story' AND (storage.foldername(name))[1] = auth.uid()::text)


-- ============================================================================
-- SECTION 4: REALTIME CONFIGURATION
-- ============================================================================

-- Enable realtime for specific tables with safety checks
DO $$
BEGIN
  -- Check if publication exists, create if not
  IF NOT EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'supabase_realtime') THEN
    CREATE PUBLICATION supabase_realtime;
  END IF;

  -- Add tables to publication if not already present
  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'messages'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.messages';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'chats'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.chats';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'participants'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.participants';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'dm_requests'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.dm_requests';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_publication_tables
    WHERE pubname = 'supabase_realtime' AND tablename = 'reports'
  ) THEN
    EXECUTE 'ALTER PUBLICATION supabase_realtime ADD TABLE public.reports';
  END IF;
END$$;


-- ============================================================================
-- SCHEMA SETUP COMPLETE
-- ============================================================================
-- This completes the database schema setup. All tables, constraints, policies,
-- and realtime configuration are now in place.
--
-- NEXT STEP: Execute functions.sql to add all database functions and triggers.
--
-- POST-DEPLOYMENT CHECKLIST:
-- ☑ Create storage buckets via Supabase Dashboard:
--   • Go to Storage section
--   • Create 'attachments' bucket (public: false)
--   • Create 'story' bucket (public: false)
--
-- ☑ Create storage policies via Supabase Dashboard:
--   For 'attachments' bucket:
--   • Policy 1: "Authenticated users can upload attachments"
--     Operation: INSERT
--     Policy: bucket_id = 'attachments' AND auth.role() = 'authenticated'
--   
--   • Policy 2: "Anyone can view attachments"
--     Operation: SELECT
--     Policy: bucket_id = 'attachments'
--   
--   For 'story' bucket:
--   • Policy 1: "Allow authenticated read access to stories"
--     Operation: SELECT
--     Policy: bucket_id = 'story' AND auth.role() = 'authenticated'
--   
--   • Policy 2: "Allow individual user uploads to stories"
--     Operation: INSERT
--     Policy: bucket_id = 'story' AND (storage.foldername(name))[1] = auth.uid()::text
--
-- ☑ Test authentication flow and profile creation
-- ☑ Verify RLS policies are working as expected
-- ☑ Test realtime subscriptions for critical tables
--
-- Version: 2.0 (Production Ready - QA Approved)
-- Last Updated: 2025-11-03
-- ============================================================================


-- 03 November 2025 01:17 IST

-- ============================================================================
--                    UPDATE_SCHEMA.SQL - DEMOCRATIZATION MIGRATION
-- ============================================================================
-- Description: This script refactors the database schema to remove admin-centric
--              features and introduce a user-driven, democratized model.
--              It removes admin roles, the DM request system, and updates
--              permissions to use a 'verified' user status.
--
-- Usage: Run this script ONCE on a database that was set up with the old schema.sql
-- ============================================================================


-- ============================================================================
-- SECTION 1: CLEANUP OLD POLICIES
-- Drop RLS policies that depend on the admin role before dropping columns.
-- ============================================================================

-- Drop policies from 'reports' table
DROP POLICY IF EXISTS "Admins can manage all reports" ON public.reports;

-- Drop policies from 'events' table
DROP POLICY IF EXISTS "Admins can create events." ON public.events;
DROP POLICY IF EXISTS "Admins or event creator can update events." ON public.events;
DROP POLICY IF EXISTS "Admins or event creator can delete events." ON public.events;

-- Drop admin-level update policy from 'messages' table
DROP POLICY IF EXISTS "Enable UPDATE for group admins on messages" ON public.messages;

-- ============================================================================
-- SECTION 2: REMOVE ADMIN AND DM-RELATED SCHEMA ELEMENTS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- TABLE: profiles - Remove admin columns and add 'verified' status
-- ----------------------------------------------------------------------------
ALTER TABLE public.profiles
    DROP COLUMN IF EXISTS is_admin,
    DROP COLUMN IF EXISTS role,
    ADD COLUMN IF NOT EXISTS verified BOOLEAN DEFAULT FALSE NOT NULL;

COMMENT ON COLUMN public.profiles.verified IS 'Indicates if a user is verified and can access special features like event creation.';

-- ----------------------------------------------------------------------------
-- TABLE: dm_requests - Remove the entire table for DM requests
-- ----------------------------------------------------------------------------
DROP TABLE IF EXISTS public.dm_requests;

-- ----------------------------------------------------------------------------
-- ENUM TYPES - Remove obsolete enums
-- ----------------------------------------------------------------------------
DROP TYPE IF EXISTS public.user_role;
DROP TYPE IF EXISTS public.dm_request_status;

-- ============================================================================
-- SECTION 3: UPDATE FUNCTIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- FUNCTION: handle_new_user
-- Purpose: Updates the trigger function to remove admin role assignment and
--          add the default 'verified' status for new users.
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, name, username, avatar_url, gender, verified)
    VALUES (
        NEW.id,
        NEW.raw_user_meta_data->>'name',
        NEW.raw_user_meta_data->>'username',
        NEW.raw_user_meta_data->>'avatar_url',
        NEW.raw_user_meta_data->>'gender',
        FALSE -- All new users are NOT verified by default
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================================================
-- SECTION 4: RECREATE RLS POLICIES WITH NEW LOGIC
-- ============================================================================

-- ----------------------------------------------------------------------------
-- POLICIES: events (Updated for 'verified' users)
-- ----------------------------------------------------------------------------

-- Policy for creating events (changed from is_admin to verified)
CREATE POLICY "Verified users can create events."
    ON public.events FOR INSERT
    WITH CHECK (
        (SELECT verified FROM public.profiles WHERE id = auth.uid()) = true
    );

-- Policy for updating events (changed from is_admin to verified)
CREATE POLICY "Verified users or event creators can update events."
    ON public.events FOR UPDATE
    USING (
        (SELECT verified FROM public.profiles WHERE id = auth.uid()) = true OR
        creator_id = auth.uid()
    );

-- Policy for deleting events (changed from is_admin to verified)
CREATE POLICY "Verified users or event creators can delete events."
    ON public.events FOR DELETE
    USING (
        (SELECT verified FROM public.profiles WHERE id = auth.uid()) = true OR
        creator_id = auth.uid()
    );


-- ----------------------------------------------------------------------------
-- POLICIES: reports (Democratized)
-- We keep the existing policy that allows any user to create a report.
-- The admin management policy was already dropped. No new policies needed here
-- for a fully democratized system, as reports would be handled externally.
-- ----------------------------------------------------------------------------
-- NOTE: The policy "Users can insert their own reports" is sufficient for the
-- democratized model. Management of reports would occur outside the RLS scope
-- by a support team with elevated privileges.


-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================
-- This completes the database schema migration. The database now reflects a
-- democratized, user-driven model.
--
-- NEXT STEP: Verify all application features work as expected with the new
--            permission system.
-- ============================================================================

-- 03 NOVEMVER 2025 01:43 IST
-- ============================================================================
--                    LISTS_SCHEMA.SQL - MIGRATION FOR LISTS FEATURE
-- ============================================================================
-- Description: This script adds the necessary tables and policies to support the
--              custom user lists feature.
--
-- Usage: Run this script once to add the lists functionality to your database.
-- ============================================================================


-- ============================================================================
-- SECTION 1: TABLE DEFINITIONS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- TABLE: lists
-- Purpose: Stores the custom lists created by users.
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.lists (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    owner_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    is_private BOOLEAN DEFAULT TRUE NOT NULL,
    CONSTRAINT lists_owner_id_name_key UNIQUE (owner_id, name)
);

COMMENT ON TABLE public.lists IS 'Stores custom user-created lists for curating content feeds.';
COMMENT ON COLUMN public.lists.owner_id IS 'The user who owns and manages the list.';


-- ----------------------------------------------------------------------------
-- TABLE: list_members
-- Purpose: Maps users to the lists they are members of.
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.list_members (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    list_id BIGINT NOT NULL REFERENCES public.lists(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    CONSTRAINT list_members_list_id_user_id_key UNIQUE (list_id, user_id)
);

COMMENT ON TABLE public.list_members IS 'Acts as a join table between lists and the profiles included in them.';


-- ============================================================================
-- SECTION 2: ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS for the new tables
ALTER TABLE public.lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.list_members ENABLE ROW LEVEL SECURITY;

-- ----------------------------------------------------------------------------
-- POLICIES: lists
-- ----------------------------------------------------------------------------

DROP POLICY IF EXISTS "Users can view their own lists." ON public.lists;
CREATE POLICY "Users can view their own lists."
    ON public.lists FOR SELECT
    USING (owner_id = auth.uid());

DROP POLICY IF EXISTS "Users can create their own lists." ON public.lists;
CREATE POLICY "Users can create their own lists."
    ON public.lists FOR INSERT
    WITH CHECK (owner_id = auth.uid());

DROP POLICY IF EXISTS "Users can update their own lists." ON public.lists;
CREATE POLICY "Users can update their own lists."
    ON public.lists FOR UPDATE
    USING (owner_id = auth.uid());

DROP POLICY IF EXISTS "Users can delete their own lists." ON public.lists;
CREATE POLICY "Users can delete their own lists."
    ON public.lists FOR DELETE
    USING (owner_id = auth.uid());


-- ----------------------------------------------------------------------------
-- POLICIES: list_members
-- ----------------------------------------------------------------------------

DROP POLICY IF EXISTS "Users can view members of lists they own." ON public.list_members;
CREATE POLICY "Users can view members of lists they own."
    ON public.list_members FOR SELECT
    USING (EXISTS (
        SELECT 1 FROM public.lists
        WHERE lists.id = list_members.list_id AND lists.owner_id = auth.uid()
    ));

DROP POLICY IF EXISTS "Users can add members to lists they own." ON public.list_members;
CREATE POLICY "Users can add members to lists they own."
    ON public.list_members FOR INSERT
    WITH CHECK (EXISTS (
        SELECT 1 FROM public.lists
        WHERE lists.id = list_members.list_id AND lists.owner_id = auth.uid()
    ));

DROP POLICY IF EXISTS "Users can remove members from lists they own." ON public.list_members;
CREATE POLICY "Users can remove members from lists they own."
    ON public.list_members FOR DELETE
    USING (EXISTS (
        SELECT 1 FROM public.lists
        WHERE lists.id = list_members.list_id AND lists.owner_id = auth.uid()
    ));


-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================

-- 1. Remove DM Request and Report tables/types (since admin panel is gone)
DROP TABLE IF EXISTS public.dm_requests CASCADE;
DROP TABLE IF EXISTS public.reports CASCADE;
DROP TYPE IF EXISTS public.dm_request_status;
DROP TYPE IF EXISTS public.report_status;

-- 2. Remove policies that depended on site-admin
DROP POLICY IF EXISTS "Admins can update any profile" ON public.profiles;
DROP POLICY IF EXISTS "Admins can manage all events" ON public.events;
DROP POLICY IF EXISTS "Users can create events if they are an admin" ON public.events;

-- 3. Remove the admin/role columns from the profiles table
ALTER TABLE public.profiles
DROP COLUMN IF EXISTS role,
DROP COLUMN IF EXISTS is_admin;

-- 4. Drop the user_role type
DROP TYPE IF EXISTS public.user_role;

-- 5. Add new policies for event creation (allow all users) and management (allow creator)
CREATE POLICY "Authenticated users can create events" ON public.events
FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Creator can manage their own event" ON public.events
FOR ALL USING (auth.uid() = creator_id);

-- ============================================================================
--                    SOCIAL MEDIA MIGRATION (Step 1)
-- ============================================================================
-- Description: This script adds the foundation for a social media "follow"
--              model, including private accounts and follow requests.
--              It REPLACES the 'blocked_users' table.
--
-- Usage: Run this file ONCE to update your schema.
-- ============================================================================


-- ============================================================================
-- SECTION 1: UPDATE PROFILES TABLE
-- ============================================================================

-- Add 'is_private' column to profiles, defaulting to 'false' (public)
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS is_private BOOLEAN DEFAULT FALSE NOT NULL;

COMMENT ON COLUMN public.profiles.is_private IS 'If true, users must request to follow this profile.';


-- ============================================================================
-- SECTION 2: CREATE RELATIONSHIPS TABLE
-- This table will manage all user-to-user relationships: follows,
-- pending requests, and blocks. This replaces the 'blocked_users' table.
-- ============================================================================

-- Drop the old 'blocked_users' table as this new table replaces it
DROP TABLE IF EXISTS public.blocked_users;

-- Create an ENUM type for relationship statuses
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'relationship_status') THEN
        CREATE TYPE public.relationship_status AS ENUM (
            'pending',    -- A follow request is waiting for approval
            'approved',   -- The follow is active
            'blocked'     -- The 'user_one_id' has blocked 'user_two_id'
        );
    END IF;
END$$;

-- Create the relationships table
CREATE TABLE IF NOT EXISTS public.relationships (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_one_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    user_two_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status public.relationship_status NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,

    -- 'user_one_id' is the one initiating the action (follower, blocker)
    -- 'user_two_id' is the one being acted upon (followed, blocked)
    CONSTRAINT unique_relationship UNIQUE (user_one_id, user_two_id),
    CONSTRAINT check_not_self_relationship CHECK (user_one_id <> user_two_id)
);

COMMENT ON TABLE public.relationships IS 'Manages all user-to-user relationships (follows, requests, blocks).';
COMMENT ON COLUMN public.relationships.user_one_id IS 'The user initiating the relationship (e.g., the follower, the blocker).';
COMMENT ON COLUMN public.relationships.user_two_id IS 'The user receiving the relationship (e.g., the one being followed, the one being blocked).';


-- ============================================================================
-- SECTION 3: RLS POLICIES FOR RELATIONSHIPS
-- ============================================================================
ALTER TABLE public.relationships ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can manage their own relationships" ON public.relationships;
CREATE POLICY "Users can manage their own relationships"
    ON public.relationships FOR ALL
    USING ( auth.uid() = user_one_id OR auth.uid() = user_two_id );

DROP POLICY IF EXISTS "Users can view all approved/blocked relationships" ON public.relationships;
CREATE POLICY "Users can view all approved/blocked relationships"
    ON public.relationships FOR SELECT
    USING ( status IN ('approved', 'blocked') );

DROP POLICY IF EXISTS "Users can view their own pending requests" ON public.relationships;
CREATE POLICY "Users can view their own pending requests"
    ON public.relationships FOR SELECT
    USING ( status = 'pending' AND (auth.uid() = user_one_id OR auth.uid() = user_two_id) );

-- ============================================================================
-- SECTION 4: UPDATE 'handle_new_user' FUNCTION (from functions.sql)
-- This OVERWRITES the existing function to add the 'is_private' default.
-- ============================================================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, name, username, avatar_url, gender, verified, is_private)
    VALUES (
        NEW.id,
        NEW.raw_user_meta_data->>'name',
        NEW.raw_user_meta_data->>'username',
        NEW.raw_user_meta_data->>'avatar_url',
        NEW.raw_user_meta_data->>'gender',
        FALSE, -- All new users are NOT verified by default
        FALSE  -- All new users are public by default
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- MIGRATION COMPLETE
-- ============================================================================

-- ============================================================================
--                    SOCIAL MEDIA MIGRATION (Step 2)
-- ============================================================================
-- Description: This script adds the notifications table and triggers
--              to support follow requests and future social features.
--
-- Usage: Run this file ONCE to add notification functionality.
-- ============================================================================


-- ============================================================================
-- SECTION 1: CREATE NOTIFICATION TYPES AND TABLE
-- ============================================================================

-- Create an ENUM for different notification types
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
        CREATE TYPE public.notification_type AS ENUM (
            'follow_request',
            'new_follower',
            'new_like',
            'new_comment'
            -- We can add more types here later
        );
    END IF;
END$$;

-- Create the notifications table
CREATE TABLE IF NOT EXISTS public.notifications (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,    -- Who the notification is FOR
    actor_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,   -- Who triggered the notification
    type public.notification_type NOT NULL,
    entity_id BIGINT,                                -- e.g., the ID of the post that was liked/commented on
    is_read BOOLEAN DEFAULT FALSE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,

    CONSTRAINT check_not_self_notification CHECK (user_id <> actor_id)
);

COMMENT ON TABLE public.notifications IS 'Stores all user-facing notifications.';
COMMENT ON COLUMN public.notifications.user_id IS 'The user who will receive the notification.';
COMMENT ON COLUMN public.notifications.actor_id IS 'The user who performed the action (e.g., the follower, the liker).';
COMMENT ON COLUMN public.notifications.entity_id IS 'The ID of the related object (e.g., post, comment). Null for follows.';


-- ============================================================================
-- SECTION 2: RLS POLICIES FOR NOTIFICATIONS
-- ============================================================================

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can only see their own notifications" ON public.notifications;
CREATE POLICY "Users can only see their own notifications"
    ON public.notifications FOR SELECT
    USING ( auth.uid() = user_id );

DROP POLICY IF EXISTS "Users can update their own notifications (mark as read)" ON public.notifications;
CREATE POLICY "Users can update their own notifications (mark as read)"
    ON public.notifications FOR UPDATE
    USING ( auth.uid() = user_id );

-- Note: Inserts will be handled by trigger functions (SECURITY DEFINER)


-- ============================================================================
-- SECTION 3: TRIGGERS FOR NOTIFICATIONS
-- ============================================================================

-- Function to create a notification on a new follow request
CREATE OR REPLACE FUNCTION public.handle_new_follow_request()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert a notification for the user being followed
    INSERT INTO public.notifications (user_id, actor_id, type)
    VALUES (NEW.user_two_id, NEW.user_one_id, 'follow_request');
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function AFTER a pending request is inserted
DROP TRIGGER IF EXISTS on_new_follow_request_create_notification ON public.relationships;
CREATE TRIGGER on_new_follow_request_create_notification
    AFTER INSERT ON public.relationships
    FOR EACH ROW
    WHEN (NEW.status = 'pending')
    EXECUTE FUNCTION public.handle_new_follow_request();


-- ============================================================================
-- SECTION 4: HELPER FUNCTIONS FOR NOTIFICATIONS
-- ============================================================================

-- Function to mark all of a user's notifications as read
CREATE OR REPLACE FUNCTION public.mark_all_notifications_as_read()
RETURNS void AS $$
BEGIN
    UPDATE public.notifications
    SET is_read = true
    WHERE user_id = auth.uid() AND is_read = false;
END;
$$ LANGUAGE plpgsql;


-- ============================================================================
-- MIGRATION (Step 2) COMPLETE
-- ============================================================================

-- ============================================================================
--                    SOCIAL MEDIA MIGRATION (Step 3)
-- ============================================================================
-- Description: This script adds the tables for posts, comments,
--              and likes, and sets up notification triggers.
--
-- Usage: Run this file ONCE to add the feed/post system.
-- ============================================================================


-- ============================================================================
-- SECTION 1: CREATE POSTS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.posts (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content TEXT,
    media_urls JSONB, -- Stores an array of objects: [{url: "...", type: "image"}, {url: "...", type: "video"}]
    poll JSONB,       -- Stores poll data: {question: "...", options: [{id: 1, text: "...", votes: 0}, ...]}
    quote_of_id BIGINT REFERENCES public.posts(id) ON DELETE SET NULL, -- For "Quote Posts"
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,

    -- We can add more fields later, like 'is_promoted', 'audience_type', etc.
    CONSTRAINT check_post_has_content CHECK (
        content IS NOT NULL OR 
        media_urls IS NOT NULL OR 
        poll IS NOT NULL OR 
        quote_of_id IS NOT NULL
    )
);
COMMENT ON TABLE public.posts IS 'Stores all user-generated posts, quotes, and media.';
COMMENT ON COLUMN public.posts.media_urls IS 'Array of media objects: [{url, type}]';
COMMENT ON COLUMN public.posts.quote_of_id IS 'References the post this post is quoting.';


-- ============================================================================
-- SECTION 2: CREATE COMMENTS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.comments (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    post_id BIGINT NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    parent_comment_id BIGINT REFERENCES public.comments(id) ON DELETE CASCADE, -- For nested replies
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.comments IS 'Stores comments on posts and replies to other comments.';
COMMENT ON COLUMN public.comments.parent_comment_id IS 'If not NULL, this comment is a reply to another comment.';


-- ============================================================================
-- SECTION 3: CREATE LIKES TABLES
-- ============================================================================
CREATE TABLE IF NOT EXISTS public.post_likes (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    post_id BIGINT NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (user_id, post_id)
);
COMMENT ON TABLE public.post_likes IS 'Tracks user likes on posts.';

CREATE TABLE IF NOT EXISTS public.comment_likes (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    comment_id BIGINT NOT NULL REFERENCES public.comments(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    PRIMARY KEY (user_id, comment_id)
);
COMMENT ON TABLE public.comment_likes IS 'Tracks user likes on comments.';


-- ============================================================================
-- SECTION 4: RLS POLICIES FOR NEW TABLES
-- ============================================================================

-- RLS for Posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Posts are viewable by everyone" ON public.posts;
CREATE POLICY "Posts are viewable by everyone"
    ON public.posts FOR SELECT USING (true); -- We will handle private profiles in the app logic

DROP POLICY IF EXISTS "Users can create their own posts" ON public.posts;
CREATE POLICY "Users can create their own posts"
    ON public.posts FOR INSERT
    WITH CHECK ( auth.uid() = user_id );

DROP POLICY IF EXISTS "Users can update their own posts" ON public.posts;
CREATE POLICY "Users can update their own posts"
    ON public.posts FOR UPDATE
    USING ( auth.uid() = user_id );

DROP POLICY IF EXISTS "Users can delete their own posts" ON public.posts;
CREATE POLICY "Users can delete their own posts"
    ON public.posts FOR DELETE
    USING ( auth.uid() = user_id );

-- RLS for Comments
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Comments are viewable by everyone" ON public.comments;
CREATE POLICY "Comments are viewable by everyone"
    ON public.comments FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can create comments" ON public.comments;
CREATE POLICY "Users can create comments"
    ON public.comments FOR INSERT
    WITH CHECK ( auth.uid() = user_id );

DROP POLICY IF EXISTS "Users can delete their own comments" ON public.comments;
CREATE POLICY "Users can delete their own comments"
    ON public.comments FOR DELETE
    USING ( auth.uid() = user_id );

-- RLS for Post Likes
ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Likes are viewable by everyone" ON public.post_likes;
CREATE POLICY "Likes are viewable by everyone"
    ON public.post_likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can like/unlike posts" ON public.post_likes;
CREATE POLICY "Users can like/unlike posts"
    ON public.post_likes FOR ALL
    USING ( auth.uid() = user_id );

-- RLS for Comment Likes
ALTER TABLE public.comment_likes ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Comment likes are viewable by everyone" ON public.comment_likes;
CREATE POLICY "Comment likes are viewable by everyone"
    ON public.comment_likes FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can like/unlike comments" ON public.comment_likes;
CREATE POLICY "Users can like/unlike comments"
    ON public.comment_likes FOR ALL
    USING ( auth.uid() = user_id );


-- ============================================================================
-- SECTION 5: NEW NOTIFICATION TRIGGERS
-- ============================================================================

-- 1. Trigger for New Post Likes
CREATE OR REPLACE FUNCTION public.handle_new_like()
RETURNS TRIGGER AS $$
DECLARE
    post_author_id UUID;
BEGIN
    -- Get the author of the post that was liked
    SELECT user_id INTO post_author_id FROM public.posts WHERE id = NEW.post_id;

    -- Create a notification only if the liker is not the post author
    IF NEW.user_id <> post_author_id THEN
        INSERT INTO public.notifications (user_id, actor_id, type, entity_id)
        VALUES (post_author_id, NEW.user_id, 'new_like', NEW.post_id);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_new_like_create_notification ON public.post_likes;
CREATE TRIGGER on_new_like_create_notification
    AFTER INSERT ON public.post_likes
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_like();


-- 2. Trigger for New Comments
CREATE OR REPLACE FUNCTION public.handle_new_comment()
RETURNS TRIGGER AS $$
DECLARE
    post_author_id UUID;
BEGIN
    -- Get the author of the post that was commented on
    SELECT user_id INTO post_author_id FROM public.posts WHERE id = NEW.post_id;

    -- Create a notification only if the commenter is not the post author
    IF NEW.user_id <> post_author_id THEN
        INSERT INTO public.notifications (user_id, actor_id, type, entity_id)
        VALUES (post_author_id, NEW.user_id, 'new_comment', NEW.post_id);
    END IF;
    
    -- TODO: Add logic here later to also notify users who are @mentioned
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_new_comment_create_notification ON public.comments;
CREATE TRIGGER on_new_comment_create_notification
    AFTER INSERT ON public.comments
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_new_comment();


-- ============================================================================
-- SECTION 6: HELPER FUNCTIONS (RPCS)
-- ============================================================================

-- Function to toggle a like on a post
CREATE OR REPLACE FUNCTION public.toggle_post_like(p_post_id BIGINT)
RETURNS void AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM public.post_likes WHERE user_id = auth.uid() AND post_id = p_post_id) THEN
        DELETE FROM public.post_likes WHERE user_id = auth.uid() AND post_id = p_post_id;
    ELSE
        INSERT INTO public.post_likes (user_id, post_id) VALUES (auth.uid(), p_post_id);
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to toggle a like on a comment
CREATE OR REPLACE FUNCTION public.toggle_comment_like(p_comment_id BIGINT)
RETURNS void AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM public.comment_likes WHERE user_id = auth.uid() AND comment_id = p_comment_id) THEN
        DELETE FROM public.comment_likes WHERE user_id = auth.uid() AND comment_id = p_comment_id;
    ELSE
        INSERT INTO public.comment_likes (user_id, comment_id) VALUES (auth.uid(), p_comment_id);
    END IF;
END;
$$ LANGUAGE plpgsql;


-- ============================================================================
-- MIGRATION (Step 3) COMPLETE
-- ============================================================================