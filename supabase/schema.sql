
-- ### TABLE CREATION ###

-- Create Profiles Table
-- This table stores public user data.
create table
  public.profiles (
    id uuid not null,
    name character varying not null,
    username character varying not null,
    avatar_url character varying null,
    gender character varying null,
    bio text null,
    is_admin boolean not null default false,
    role public.user_role null default 'user'::public.user_role,
    constraint profiles_pkey primary key (id),
    constraint profiles_id_fkey foreign key (id) references auth.users (id) on delete cascade,
    constraint username_length check ((char_length(username) >= 3))
  ) tablespace pg_default;

-- Create Chats Table
-- Stores information about each chat, whether it's a DM, group, or channel.
create table
  public.chats (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    type public.chat_type not null,
    name character varying null,
    avatar_url character varying null,
    created_by uuid null,
    description text null,
    is_public boolean not null default false,
    history_visible boolean not null default true,
    invite_code text null,
    constraint chats_pkey primary key (id),
    constraint chats_created_by_fkey foreign key (created_by) references auth.users (id) on delete set null,
    constraint chats_invite_code_key unique (invite_code)
  ) tablespace pg_default;

-- Create Participants Table
-- A many-to-many relationship linking users to chats.
create table
  public.participants (
    user_id uuid not null,
    chat_id bigint not null,
    is_admin boolean not null default false,
    constraint participants_pkey primary key (user_id, chat_id),
    constraint participants_chat_id_fkey foreign key (chat_id) references public.chats (id) on delete cascade,
    constraint participants_user_id_fkey foreign key (user_id) references public.profiles (id) on delete cascade
  ) tablespace pg_default;

-- Create Messages Table
-- Stores all messages for all chats.
create table
  public.messages (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    chat_id bigint not null,
    user_id uuid not null,
    content text null,
    attachment_url text null,
    attachment_metadata jsonb null,
    is_edited boolean not null default false,
    reactions jsonb null,
    read_by uuid[] null default '{}'::uuid[],
    is_starred boolean not null default false,
    is_pinned boolean not null default false,
    reply_to_message_id bigint null,
    constraint messages_pkey primary key (id),
    constraint messages_chat_id_fkey foreign key (chat_id) references public.chats (id) on delete cascade,
    constraint messages_reply_to_message_id_fkey foreign key (reply_to_message_id) references public.messages (id) on delete set null,
    constraint messages_user_id_fkey foreign key (user_id) references public.profiles (id) on delete set null
  ) tablespace pg_default;
  
-- Create DM Requests Table
-- Manages requests for direct messages between users, especially for cross-gender communication.
create table
  public.dm_requests (
    id bigint generated by default as identity,
    from_user_id uuid not null,
    to_user_id uuid not null,
    status public.request_status not null default 'pending'::public.request_status,
    created_at timestamp with time zone not null default now(),
    reason text null,
    constraint dm_requests_pkey primary key (id),
    constraint dm_requests_from_user_id_fkey foreign key (from_user_id) references auth.users (id) on delete cascade,
    constraint dm_requests_to_user_id_fkey foreign key (to_user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

-- Create Blocked Users Table
-- Allows users to block other users.
create table
  public.blocked_users (
    blocker_id uuid not null,
    blocked_id uuid not null,
    created_at timestamp with time zone not null default now(),
    constraint blocked_users_pkey primary key (blocker_id, blocked_id),
    constraint blocked_users_blocked_id_fkey foreign key (blocked_id) references auth.users (id) on delete cascade,
    constraint blocked_users_blocker_id_fkey foreign key (blocker_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;
  
-- Create Reports Table
-- Allows users to report other users or messages for moderation.
create table
  public.reports (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    reported_by uuid not null,
    reported_user_id uuid not null,
    message_id bigint null,
    reason text not null,
    status public.request_status not null default 'pending'::public.request_status,
    constraint reports_pkey primary key (id),
    constraint reports_message_id_fkey foreign key (message_id) references public.messages (id) on delete set null,
    constraint reports_reported_by_fkey foreign key (reported_by) references auth.users (id) on delete cascade,
    constraint reports_reported_user_id_fkey foreign key (reported_user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

-- Events Tables
create table public.events (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  creator_id uuid not null,
  title text not null,
  description text null,
  thumbnail text null,
  date_time timestamp with time zone not null,
  meet_link text null,
  status public.event_status not null default 'active'::public.event_status,
  is_deleted boolean not null default false,
  constraint events_pkey primary key (id),
  constraint events_creator_id_fkey foreign key (creator_id) references public.profiles (id) on delete cascade
) tablespace pg_default;

create table public.event_rsvps (
    event_id bigint not null,
    user_id uuid not null,
    status public.rsvp_status not null,
    created_at timestamp with time zone not null default now(),
    constraint event_rsvps_pkey primary key (event_id, user_id),
    constraint event_rsvps_event_id_fkey foreign key (event_id) references public.events (id) on delete cascade,
    constraint event_rsvps_user_id_fkey foreign key (user_id) references public.profiles (id) on delete cascade
) tablespace pg_default;


-- ### CUSTOM TYPES ###
create type public.chat_type as enum ('dm', 'group', 'channel');
create type public.user_role as enum ('user', 'admin', 'gurudev');
create type public.request_status as enum ('pending', 'approved', 'rejected', 'resolved', 'dismissed');
create type public.event_status as enum ('active', 'cancelled');
create type public.rsvp_status as enum ('going', 'interested', 'not_going');


-- ### DATABASE FUNCTIONS (RPC) ###

-- Function to get the last message for a list of chat IDs
-- This is more efficient than fetching them one by one on the client.
create or replace function public.get_last_messages_for_chats(p_chat_ids bigint[]) 
returns table (
    chat_id bigint,
    content text,
    created_at timestamptz,
    attachment_metadata jsonb
) as $$
begin
    return query
    with last_messages as (
        select
            m.chat_id,
            m.content,
            m.created_at,
            m.attachment_metadata,
            row_number() over(partition by m.chat_id order by m.created_at desc) as rn
        from public.messages m
        where m.chat_id = any(p_chat_ids)
    )
    select 
        lm.chat_id,
        lm.content,
        lm.created_at,
        lm.attachment_metadata
    from last_messages lm
    where lm.rn = 1;
end;
$$ language plpgsql;


-- Function to handle user profile creation on new user signup
-- This trigger automatically creates a profile entry when a new user signs up in Supabase Auth.
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, name, username, gender, avatar_url)
  values (
    new.id, 
    new.raw_user_meta_data->>'name',
    new.raw_user_meta_data->>'username',
    new.raw_user_meta_data->>'gender',
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$ language plpgsql security definer;

-- Function to mark all messages in a chat as read by a specific user
create or replace function public.mark_messages_as_read(p_chat_id bigint, p_user_id uuid)
returns void as $$
begin
    update public.messages
    set read_by = array_append(read_by, p_user_id)
    where chat_id = p_chat_id
      and not (read_by @> array[p_user_id]);
end;
$$ language plpgsql;

-- Function to add or remove a reaction from a message's JSONB column
-- This function handles the complex logic of updating the reactions JSONB on the server
-- to prevent race conditions from clients trying to update it simultaneously.
create or replace function public.toggle_reaction(p_message_id bigint, p_emoji text, p_user_id uuid)
returns void as $$
declare
    current_reactions jsonb;
    user_ids_for_emoji uuid[];
begin
    -- Get the current reactions for the message
    select reactions into current_reactions from public.messages where id = p_message_id;

    -- If reactions is null, initialize it as an empty jsonb object
    if current_reactions is null then
        current_reactions := '{}'::jsonb;
    end if;

    -- Get the array of user_ids for the specific emoji
    user_ids_for_emoji := ARRAY(select jsonb_array_elements_text(current_reactions->p_emoji));

    if user_ids_for_emoji is null then
        -- If the emoji doesn't exist, add it with the current user
        current_reactions := jsonb_set(current_reactions, array[p_emoji], to_jsonb(array[p_user_id]));
    else
        -- If the emoji exists, check if the user is in the array
        if p_user_id = any(user_ids_for_emoji) then
            -- If user is in the array, remove them
            user_ids_for_emoji := array_remove(user_ids_for_emoji, p_user_id);
        else
            -- If user is not in the array, add them
            user_ids_for_emoji := array_append(user_ids_for_emoji, p_user_id);
        end if;
        
        if array_length(user_ids_for_emoji, 1) > 0 then
             -- If there are still users for this reaction, update the array
            current_reactions := jsonb_set(current_reactions, array[p_emoji], to_jsonb(user_ids_for_emoji));
        else
            -- If no users are left for this reaction, remove the emoji key
            current_reactions := current_reactions - p_emoji;
        end if;
    end if;

    -- Update the message with the new reactions
    update public.messages set reactions = current_reactions where id = p_message_id;
end;
$$ language plpgsql;


-- ### TRIGGERS ###

-- Trigger to call handle_new_user on new user signup
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Trigger to send a real-time notification when a new message is inserted.
create trigger on_new_message
  after insert on public.messages
  for each row execute procedure supabase_functions.http_request(
    'https://<YOUR_PROJECT_REF>.functions.supabase.co/send-push-notification',
    'POST',
    '{"Content-type":"application/json"}',
    '{}',
    '1000'
  );


-- ### ROW-LEVEL SECURITY (RLS) POLICIES ###
-- These are critical for securing your data. They ensure that users can only access data they are permitted to.

-- Profiles
alter table public.profiles enable row level security;
create policy "Public profiles are viewable by everyone." on public.profiles for select using (true);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);

-- Chats
alter table public.chats enable row level security;
create policy "Users can view chats they are a member of." on public.chats for select using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid()));
create policy "Users can create new chats." on public.chats for insert with check (auth.uid() is not null);
create policy "Admins can update group chats." on public.chats for update using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid() and is_admin = true));
create policy "Admins can delete group chats." on public.chats for delete using (exists (select 1 from public.participants where chat_id = id and user_id = auth.uid() and is_admin = true));

-- Participants
alter table public.participants enable row level security;
create policy "Users can view participants of chats they are a member of." on public.participants for select using (exists (select 1 from public.participants p where p.chat_id = participants.chat_id and p.user_id = auth.uid()));
create policy "Users can add themselves to a chat (leave)." on public.participants for insert with check (user_id = auth.uid());
create policy "Users can remove themselves from a group." on public.participants for delete using (user_id = auth.uid());
create policy "Admins can manage participants in their groups." on public.participants for all using (exists (select 1 from public.participants p where p.chat_id = participants.chat_id and p.user_id = auth.uid() and p.is_admin = true));

-- Messages
alter table public.messages enable row level security;
create policy "Users can view messages in chats they are a member of." on public.messages for select using (exists (select 1 from public.participants where chat_id = messages.chat_id and user_id = auth.uid()));
create policy "Users can insert their own messages." on public.messages for insert with check (user_id = auth.uid());
create policy "Users can update their own messages." on public.messages for update using (user_id = auth.uid());
create policy "Users can delete their own messages." on public.messages for delete using (user_id = auth.uid());
create policy "Admins can delete any message in their group." on public.messages for delete using (exists (select 1 from public.participants where chat_id = messages.chat_id and user_id = auth.uid() and is_admin = true));

-- Blocked Users
alter table public.blocked_users enable row level security;
create policy "Users can view their own blocked list." on public.blocked_users for select using (blocker_id = auth.uid());
create policy "Users can block other users." on public.blocked_users for insert with check (blocker_id = auth.uid());
create policy "Users can unblock users." on public.blocked_users for delete using (blocker_id = auth.uid());

-- DM Requests
alter table public.dm_requests enable row level security;
create policy "Users can view requests they sent or received." on public.dm_requests for select using (from_user_id = auth.uid() or to_user_id = auth.uid());
create policy "Users can send DM requests." on public.dm_requests for insert with check (from_user_id = auth.uid());
create policy "Admins can view and manage all DM requests" on public.dm_requests for all using ( (select is_admin from public.profiles where id = auth.uid()) = true );

-- Reports
alter table public.reports enable row level security;
create policy "Users can create reports." on public.reports for insert with check (reported_by = auth.uid());
create policy "Admins can view and manage all reports." on public.reports for all using ( (select is_admin from public.profiles where id = auth.uid()) = true );

-- Events
alter table public.events enable row level security;
create policy "Events are public." on public.events for select using (true);
create policy "Authenticated users can create events." on public.events for insert with check (auth.uid() is not null);
create policy "Event creators and admins can update events." on public.events for update using (auth.uid() = creator_id or (select is_admin from public.profiles where id = auth.uid()) = true);
create policy "Event creators and admins can delete events." on public.events for delete using (auth.uid() = creator_id or (select is_admin from public.profiles where id = auth.uid()) = true);

-- Event RSVPs
alter table public.event_rsvps enable row level security;
create policy "RSVPs are public." on public.event_rsvps for select using (true);
create policy "Users can create/update their own RSVP." on public.event_rsvps for all using (auth.uid() = user_id);


-- ### STORAGE POLICIES ###
-- These policies control who can access files in your Supabase Storage buckets.

-- Attachments Bucket
create policy "Users can view attachments in chats they are in."
  on storage.objects for select
  using ( bucket_id = 'attachments' and exists (select 1 from public.messages m join public.participants p on m.chat_id = p.chat_id where m.attachment_url like '%' || name and p.user_id = auth.uid()) );

create policy "Users can upload attachments."
  on storage.objects for insert
  with check ( bucket_id = 'attachments' and auth.uid() is not null );
